---
output:
  pdf_document: default
  html_document: default
---
# Appendix

## Calculate the amino acid compositions (AAC) and Di-peptide compositions (DPC) from .fasta formats, {Myoglobin, Non-Myoglobin}

Calculating the Amino Acid and Di-peptide composition of a protein string is a simple calculation requiring the total amino acid length of the peptide or poly-peptide of interest and a count of substrings. Initially, the command `seqinr::read.fasta` reads .fasta file formats and returns a list of proteins stripping away all other information. Secondly, the command `stringr::str_count()` produces an integer value of the number of substrings in a larger string, i.e. `peptide`. 

For example, `aa_nums[j] = str_count(peptide, col_titles[j]) / total_aa`, 

Where; `aa_nums[j]` is an array to saving values for later writing to file, `peptide` is the string to check, i.e. protein of interest, `col_titles[j]` is the substring which is either a single amino acid or di-peptide.

Input: .fasta  
Output: .csv

Libraries  
```{r message=FALSE, warning=FALSE}
Libraries = c("stringr", "knitr", "seqinr")

for (p in Libraries) {  # Install Libraries
    library(p, character.only = TRUE)
}
```

```{r message=FALSE, warning=FALSE, include=FALSE}
opts_chunk$set(cache = TRUE, warning = FALSE, message = FALSE, cache.lazy = FALSE, align = "center")
```

Import uniprot-myoglobin.fasta - Read peptide lines
```{r}
read_fasta <- function() {
    listo_proteins <- read.fasta(file = "../00-data/01-ORIGINAL_DATA/uniprot-myoglobin.fasta",
                            seqtype = "AA",
                            as.string = TRUE,
                            seqonly = FALSE,
                            strip.desc = TRUE)
    return(listo_proteins)
}

myoglobins <- read_fasta()
```

Column_titles
```{r}
column_titles = function() {
    peptides = c("A", "C", "D", "E", "F",
                 "G", "H", "I", "K", "L",
                 "M", "N", "P", "Q", "R",
                 "S", "T", "V", "W", "Y")
    # Add DIPEPTIDES column titles
    di_titles = vector(mode = "character", length = 400)
    k = 1
    for (i in 1:20) {
        for (j in 1:20) {
            di_titles[k] <- paste(peptides[i], peptides[j], sep = "")
            k = k + 1
        }
    }
    aa_di_titles <- c("Class","TotalAA","PID", peptides, di_titles)
    return(aa_di_titles)
}

col_titles <- column_titles()
# col_titles
```

Write empty .csv
```{r}
write_empty_csv <- function(protein_class = "C") {
    col_titles <- column_titles()
    file_name <- paste(protein_class, "_aac_dpc.csv", sep = "")
    write.table(t(col_titles), 
                file_name,  
                sep = ",", 
                col.names = FALSE, 
                row.names = FALSE, 
                eol = "\n")
    return(file_name)
}

file_name <- write_empty_csv()
```

`calc_aac_dpc` function
```{r}
calc_aac_dpc <- function(peptide, protein_class = "C", i, file_name) {
    aa_nums = matrix(0, ncol = 423)
    ###############################
    # First column is class
    aa_nums[1] = ifelse(protein_class == "C", 0, 1)
    # Second column is total number of amino acids
    total_aa = nchar(peptide)
    aa_nums[2] = total_aa
    # Third line is 'Protein ID', PID
    aa_nums[3] = paste(protein_class, i, sep = "")
    # Column 4:423 - Calculate AAC/DPC
    for (j in 4:423) {
        aa_nums[j] = str_count(peptide, col_titles[j]) / total_aa
        }
    write(t(aa_nums), file = file_name, append = TRUE, ncolumns = 423, sep = ",")
}
```

#############
RUN Myoglobin
```{r}
# RUN Myoglobin
for (i in 1:1124) {
    peptide <- myoglobins[[i]][1]
    calc_aac_dpc(peptide, protein_class = "M", i, file_name)
}
```

#################################
RUN Control / Human-NOT-myoglobin 

- Import data - Read peptide lines
```{r}
read_fasta <- function() {
    listo_proteins <- read.fasta(file = "../00-data/01-ORIGINAL_DATA/uniprot-human+NOT+hemoglobin+NOT+myoglobin+random.fasta",
                            seqtype = "AA",
                            as.string = TRUE,
                            seqonly = FALSE,
                            strip.desc = TRUE)
    return(listo_proteins)
}

controls <- read_fasta()
```

RUN controls
```{r}
for (i in 1:1216) {
    peptide <- controls[[i]][1]
    calc_aac_dpc(peptide, protein_class = "C", i, file_name)
}
```
EOF---
title: "KEEP AAC ONLY FOR RAW DATA"
author: "MCC"
date: "12/5/2019"
output: html_document
---

```{r}
C_M_aac_dpc <- read.csv("../00-data/02-aac_dpc_values/C_M_aac_dpc.csv",
                        stringsAsFactors = FALSE)
# View(`C+M_aac_dpc`)

## Select 1st thru 23rd variables
c_m_RAW_AAC <- C_M_aac_dpc[c(1:23)]
```

- To A Comma Delimited Text File
```{r}
#setwd("../00-data/02-aac_dpc_values/")

write.table(c_m_RAW_AAC, 
            file = "../00-data/02-aac_dpc_values/c_m_RAW_AAC.csv", 
            sep = ",", 
            row.names = F)
```
---
title: "Transform {C, F, I} from c_m_RAW_AAC"
author: "MCC"
date: "12/5/2019"
output: html_document
---

```{r}
library(readr)

c_m_RAW_AAC <- read_csv("../00-data/02-aac_dpc_values/c_m_RAW_AAC.csv", 
                        col_types = cols(Class = col_factor(levels = c("0","1"))))
c_m_TRANSFORMED_AAC <- c_m_RAW_AAC
```

1. Transfrom C,F,I using sqrt(x)  
2. Columns: C=5, F=8, I=11  

```{r}
c_m_TRANSFORMED[, 5] <- sqrt(c_m_TRANSFORMED[, 5]) # C
c_m_TRANSFORMED[, 8] <- sqrt(c_m_TRANSFORMED[, 8]) # F
c_m_TRANSFORMED[,11] <- sqrt(c_m_TRANSFORMED[,11]) # I

write_csv(c_m_TRANSFORMED, 
          file = "../00-data/02-aac_dpc_values/c_m_TRANSFORMED.csv", 
          col_names = T)
```


---
title: 'Appendix: Machine Setting & Session Info'
author: "MCC"
date: "8/13/2019"
output: html_document
---

```{r, include=FALSE}
library(knitr)
opts_chunk$set(cache = TRUE, warning = FALSE, message = FALSE)
```

```{r}
Sys.info()[c(1:3,5)]
```

```{r}
sessionInfo()
```

# Support Vector Machine; svmPoly Model

## Introduction

```{r message=FALSE, warning=FALSE}
## Load Libraries
Libraries = c("doMC", "knitr", "readr", "tidyverse", "caret", "kernlab")
for(p in Libraries){  # Install Library if not present
    if(!require(p, character.only = TRUE)) { install.packages(p) }
    library(p, character.only = TRUE)
}
opts_chunk$set(cache = TRUE)
```

Import data & data handling
```{r}
c_m_TRANSFORMED <- read_csv("../00-data/aac_dpc_values/c_m_TRANSFORMED.csv",
                            col_types = cols(Class = col_factor(levels = c("0","1")), 
                                             PID = col_skip(), TotalAA = col_skip()))
#View(c_m_TRANSFORMED)
```

Partition data into training and testing sets
```{r}
set.seed(1000)
index <- createDataPartition(c_m_TRANSFORMED$Class, p = 0.8, list = FALSE)

training_set <- c_m_TRANSFORMED[ index,]
test_set     <- c_m_TRANSFORMED[-index,]

Class_test <- as.factor(test_set$Class)
```

## `svmPoly` Model
```{r, cache=TRUE}
set.seed(1000)
registerDoMC(cores = 3) # Start multi-processor mode 
start_time <- Sys.time() # Start timer

# Create model, 10X fold CV repeated 5X
tcontrol <- trainControl(method = "repeatedcv",
                         number = 10,
                         repeats = 5,
                         savePredictions = "final") # IMPORTANT: this saves predictions for later retreival

# Train
model_obj <- train(Class ~ .,
                   data = training_set,
                   method = "svmPoly",
                   trControl= tcontrol)

end_time <- Sys.time()   # End timer
end_time - start_time    # Display time
registerDoSEQ() # Stop multi-processor mode 
```

## `svmPoly`: Model Summary
```{r}
model_obj
```

## `svmPoly`: Predict new samples (Class_test)
```{r, cache=TRUE}
Predicted_test_vals <- predict(model_obj, test_set[, -1])

summary(Predicted_test_vals)
```

## `svmPoly`: Confusion Matrix
```{r}
confusionMatrix(Predicted_test_vals, Class_test)
```

## Obtain False Positives & False Negatives

```{r}
fp_fn_svm_poly <- model_obj %>% pluck("pred") %>% dplyr::filter(obs != pred)

# Write CSV in R
write.table(fp_fn_svm_poly, 
            file = "../20-outliers/fp_fn_svm_poly.csv", 
            row.names = FALSE, 
            na = "", 
            col.names = TRUE, 
            sep=",")

fp_fn_svm_poly
```

EOF
